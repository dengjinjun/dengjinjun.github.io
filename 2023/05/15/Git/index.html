<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Git" />
    <meta name="hexo-theme-A4" content="v1.9.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Dengpangpang</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Dengpangpang</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">🍟首页</a></li>
            
        
            
                <li><a href="/list/">📝文章</a></li>
            
        
            
                <li><a href="/tags/">🏷️标签</a></li>
            
        
            
                <li><a href="/categories/">🗂️分类</a></li>
            
        
            
                <li><a href="/about/">👁️关于</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Git
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Git%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E5%8F%91%E5%B1%95"><span class="post-toc-text">Git的起源和发展</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F"><span class="post-toc-text">集中式和分布式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%89%E8%A3%85Git"><span class="post-toc-text">安装Git</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="post-toc-text">本地仓库管理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="post-toc-text">远程仓库管理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="post-toc-text">分支管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="post-toc-text">分支的基本操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5"><span class="post-toc-text">分支合并策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="post-toc-text">解决冲突</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86"><span class="post-toc-text">标签管理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="post-toc-text">忽略特殊文件</span></a></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="Git的起源和发展"><a href="#Git的起源和发展" class="headerlink" title="Git的起源和发展"></a>Git的起源和发展</h2><p>Git的诞生要从Linux说起，大佬Linus在1991年创建了开源的Linux系统，从此，Linux系统不断发展，由全世界热心的志愿者参与编写代码，如今已经成为最大的服务器系统软件。</p>
<blockquote>
<p><strong>早期Linux的代码是如何管理的呢？</strong></p>
</blockquote>
<p>事实上，从Linux系统诞生之后的十年间，源代码文件是世界各地的开发者通过diff的方式发给Linus，然后由Linus本人手动合并的！</p>
<blockquote>
<p><strong>为什么不使用版本控制软件呢？</strong></p>
</blockquote>
<p>当时确实是存在一些商用的版本控制系统，以及一些开源的软件比如CVS和SVN，但是Linus都没有采用，拒绝前者的原因是付费软件不符合Linux的开源精神，而拒绝后者的原因的是Linus本人坚定地嫌弃CVS和SVN这些集中式的版本控制系统（下部分详述）。</p>
<blockquote>
<p><strong>Git诞生的直接原因</strong></p>
</blockquote>
<p>随着Linux的代码库越来越庞大，即便Linus本人再偏执，也终究要考虑Linux开源社区贡献者们的强烈不满，于是接受了商业版本控制系统BitKeeper的免费使用的授权。就这样岁月静好了三年，社区的另一个大佬 Andrew（Samba作者）尝试破解BitKeeper的协议，事情被发现之后，Linux的授权被收回。Linus得知之后对这一行为很气愤，然后花了两周时间用C语言写了一个分布式版本控制系统，Git自此诞生。</p>
<blockquote>
<p><strong>Git的发展</strong></p>
</blockquote>
<p>Git灵活方便，以及分布式的特点顺应趋势，很快流行了起来。随后GitHub网站上线，为开源项目免费提供Git存储，无数开源项目迁移到GitHub上，自此Git的地位无可撼动。</p>
<h2 id="集中式和分布式"><a href="#集中式和分布式" class="headerlink" title="集中式和分布式"></a>集中式和分布式</h2><p>本节介绍让Linus如此嫌弃的集中式版本控制系统与Git（分布式版本控制系统）有何区别</p>
<blockquote>
<p><strong>集中式版本控制系统</strong></p>
</blockquote>
<p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p><a href="/../pic/l-170879680357210.jpeg" title="central-repo" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/l-170879680357210.jpeg" alt="central-repo"></a></p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p>
<blockquote>
<p><strong>分布式版本控制系统</strong></p>
</blockquote>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。任何两台电脑之间，都可以互相推送自己修改过的版本。</p>
<p><a href="/../pic/l-17065248263303-170879680357212.jpeg" title="distributed-repo" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/l-17065248263303-170879680357212.jpeg" alt="distributed-repo"></a></p>
<p>事实上，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，不过它并不是必需的，而是在多人协同开发的场景中为了方便统一版本才这么做的，如果当前的中央服务器爆炸了，它也可以是其他的任意一台电脑；而如果SVN中的中央服务器爆炸了，那开发组就真的爆炸了。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><blockquote>
<p><strong>Linux</strong></p>
</blockquote>
<p>可选源码安装，也可以使用Linux系统的包管理器安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Windows</strong></p>
</blockquote>
<p>在Git官网<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">下载安装包</a>，然后根据引导安装即可。Windows下需要配置用户名和邮箱。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="本地仓库管理"><a href="#本地仓库管理" class="headerlink" title="本地仓库管理"></a>本地仓库管理</h2><blockquote>
<p><strong>工作区、暂存区、版本库的概念</strong></p>
</blockquote>
<p>要轻松地使用Git，首先必须了解工作区、暂存区和版本库的概念</p>
<p><strong>工作区（Working Directory）：就是电脑里显示的目录</strong></p>
<p><strong>版本库（Repository）：是一个隐藏的仓库，存储了提交之后的各个版本，可以理解为一个快照</strong></p>
<p><strong>暂存区（stage）：介于工作区和版本库之间，暂存修改之后的工作区文件，一般文件修改之后，不会立即提交版本库，一般是把修改过的文件都放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p>
<p><a href="/../pic/0-170879680357314.jpeg" title="git-repo" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/0-170879680357314.jpeg" alt="git-repo"></a></p>
<p>从上图中可以看到，在版本库的内部有个指向当前版本的<code>HEAD</code>指针，当需要回退版本的时候，Git把HEAD从当前版本指向需要回退到的版本。</p>
<blockquote>
<p><strong>查看仓库状态</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>将工作区文件添加进暂存区</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;		# 添加某个文件进暂存区</span><br><span class="line">git add .			# 添加所有文件进暂存区</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>删除文件</strong></p>
</blockquote>
<p>场景：删除一个工作区中的文件之后，可以再把文件从暂存区删除，然后再提交到版本库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 此命令是从暂存区中删除文件</span><br><span class="line">git rm &lt;file&gt;		# 从暂存区中删除之后，可以git commit, 该文件也会从版本库中删除</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>将暂存区文件提交到版本库</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;some message&quot;		# 提交后将会生成一个版本，提交之后暂存区就是“干净”的了</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>查看Git版本库时间线</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log		# 显示从最近到最远的版本信息，可以看到版本号，作者信息，日期，以及提交的版本信息</span><br><span class="line">git log --pretty=oneline		# 一次提交用一行信息来显示，只显示版本号和版本信息</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>查看Git命令日志</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog		# 每一次命令都会被记录在这里，也可以看到历史的提交记录，用来找丢失的版本号很方便</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>撤销修改</strong></p>
</blockquote>
<ul>
<li><p>场景1：在工作区修改了，还没添加到暂存区，想要撤销修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;		# 撤销工作区中的修改，回到最近一次的`git add`或者`git commit`的状态</span><br><span class="line"># 也可以理解为：先从缓存区中拉取版本还原，如果没有再到版本库中拉取还原。</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景2：在工作区修改了之后，又添加到暂存区了，想要撤销修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;		# 撤销暂存区中的修改，撤销之后暂存区就是干净的了，如果想要进一步撤销工作区的修改，可以参考场景1</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景3：在工作区修改了之后，添加到了暂存区，又提交到了版本库，想要回退版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^		# 回到上个版本，HEAD表示当前版本，HEAD^表示上个版本，HEAD^^表示上上个版本，以此类推……</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景4：回退版本之后，又想要回到回退之前的那个版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 这个场景用上个命令无法实现，因为HEAD无法表示回退之前的那个版本</span><br><span class="line"># 这是回退之前</span><br><span class="line">┌────┐														</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──▶ ○ distribution A 		# 当前版本A HEAD	</span><br><span class="line">        │</span><br><span class="line">        ○ distribution B		# 版本B 用 HEAD^ 表示</span><br><span class="line">        │</span><br><span class="line">        ○ distribution C		# 版本C HEAD^^</span><br><span class="line"></span><br><span class="line"># 回退之后,想要回到版本A</span><br><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ distribution A 		# ？？？</span><br><span class="line">   │    │</span><br><span class="line">   └──▶ ○ distribution B		# 版本B变成了当前版本，用 HEAD 表示</span><br><span class="line">        │</span><br><span class="line">        ○ distribution C		# 版本C 用 HEAD^ 表示</span><br><span class="line"></span><br><span class="line"># 此时可以使用另一种写法，就是用版本号来表示版本，不再使用HEAD来表示了</span><br><span class="line">git reset --hard 1094a		# 版本号可以通过git reflog命令来找到，只需要写前几位即可，Git会自动匹配正确的版本</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h2><p>在本地创建了一个Git仓库后，还可以在GitHub上创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p>
<blockquote>
<p><strong>将本地仓库与远程仓库关联</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个远程仓库，git remote add origin [git远程仓库地址]</span><br><span class="line"># 此处的origin是指添加的远程仓库的名字，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。比如：</span><br><span class="line"># git remote add origin git@github.com:dengjinjun/emo.git</span><br><span class="line"></span><br><span class="line"># 添加完成之后，可以查看远程仓库的信息</span><br><span class="line">git remote</span><br><span class="line">git remote -v 	# 显示更详细的信息，可以抓取和推送的地址</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>把本地库分支推送到远程仓库</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 把本地库的master分支上的内容推送到远程仓库的master分支，用git push命令</span><br><span class="line">git push -u origin master</span><br><span class="line"># 由于远程库是空的，第一次推送master分支时需要加上-u参数，把本地的master分支和远程的master分支关联起来，后续可省略 -u</span><br><span class="line"># git push origin master</span><br><span class="line"></span><br><span class="line"># 如果要推送其他分支，比如dev分支，先在本地切换到dev分支，然后推送到远程仓库的dev分支</span><br><span class="line">git push origin dev		# 第一次也需要添加-u参数</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>在多人协作中，哪些分支需要推送，哪些分支不需要</p>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<blockquote>
<p><strong>从远程仓库拉取分支</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/gitskills.git		# 如果是新建的本地库，默认只能看到master分支</span><br><span class="line">git checkout -b dev origin/dev		# 本地新建dev分支，并从远程仓库的dev分支拉取内容</span><br><span class="line">git branch --set-upstream-to=origin/dev dev		# 第一次拉取可能会失败，需要先使用这个命令建立连接</span><br><span class="line">git pull		# 后续可以直接使用这条命令拉取，如果与本地有冲突也需要解决冲突</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<blockquote>
<p><strong>删除一个远程仓库</strong></p>
</blockquote>
<p>此处的 “删除” 其实是解除本地库和远程仓库的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。</p>
<p>如果添加的时候地址写错了，或者就是想删除远程库，可以解除本地库与远程库之间的关联，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote -v		# 使用前，建议先查看远程库信息</span><br><span class="line">git remote rm origin		# origin是远程库的名字</span><br></pre></td></tr></table></figure>

<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="分支的基本操作"><a href="#分支的基本操作" class="headerlink" title="分支的基本操作"></a>分支的基本操作</h3><blockquote>
<p><strong>分支管理的概念</strong></p>
</blockquote>
<p>讲起分支，一个离不开的概念就是指针，在我的理解中，一个分支就是一个指针。</p>
<p>Git中，分支的管理非常重要，在之前的本地仓库管理的版本库概念介绍中，<code>HEAD</code>指针好像是指向了最新的提交，其实并不是这样的，<code>HEAD</code>指针永远都指向某一个分支指针。</p>
<p>在只有一条分支，即只有一条<code>master</code>分支的情况下，<code>HEAD</code>指针指向<code>master</code>指针，而<code>master</code>指针指向最新的提交，所以看起来是<code>HEAD</code>指针指向了最新的提交。</p>
<p><a href="/../pic/image-20240305031404554.png" title="image-20240305031404554" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/image-20240305031404554.png" alt="image-20240305031404554"></a></p>
<p>当我们创建了另一条分支的时候，比如使用<code>git branch dev</code>命令创建一个<code>dev</code>分支，Git只是添加了一个<code>dev</code>指针，让它指向了当前所在的提交，其他什么都没做。然后我们可以使用<code>git switch dev</code>命令切换到<code>dev</code>分支，本质上是让<code>HEAD</code>指针指向<code>dev</code>指针。不过现在<code>dev</code>指针和<code>master</code>指针指向的是同一个提交。</p>
<p><a href="/../pic/image-20240305043430212.png" title="image-20240305043430212" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/image-20240305043430212.png" alt="image-20240305043430212"></a></p>
<p>接下来，在本地仓库中，对工作区的修改和提交就是针对<code>dev</code>分支了，与<code>master</code>分支无关。比如新提交一次后，<code>dev</code>指针会移向最新的提交，向前移动一格，而<code>master</code>分支不动。</p>
<p><a href="/../pic/image-20240305043901656.png" title="image-20240305043901656" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/image-20240305043901656.png" alt="image-20240305043901656"></a></p>
<p>一般来说，<code>dev</code>分支是为了开发工作而创建的，当我们开发好了之后，必然要合并到<code>master</code>分支上去，这个合并的操作也很简单，需要先回到<code>master</code>分支，<code>git switch master</code>，然后使用命令<code>git merge dev</code>，就完成了合并。其实本质上只是简单地把<code>master</code>指针指向了<code>dev</code>指针。</p>
<p><a href="/../pic/image-20240305044641165.png" title="image-20240305044641165" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/image-20240305044641165.png" alt="image-20240305044641165"></a></p>
<p>这种方式是<code>Fast-Forward</code>模式，即快进模式。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，后面会讲其他方式的合并。</p>
<p>合并之后就可以删除<code>dev</code>分支了，使用命令<code>git branch -d dev</code></p>
<blockquote>
<p><strong>基本操作命令</strong></p>
</blockquote>
<ul>
<li><p>创建分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整到某分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;name&gt;		# 旧命令是git checkout &lt;name&gt;，但是容易与前面的撤销修改混淆，不建议使用</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并调整到某分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch -c &lt;name&gt;	# 旧命令：git checkout -b &lt;name&gt;，不建议使用</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并某分支到当前分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;name&gt;	# 分支合并到主分支后，可以使用此命令删掉分支</span><br><span class="line">git branch -D &lt;name&gt;	# 如果分支还没有合并到主分支，想要删除掉（比如某个开发中的功能不需要了），使用-D参数来强制删除</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分支合并策略"><a href="#分支合并策略" class="headerlink" title="分支合并策略"></a>分支合并策略</h3><p>merge的动作是把目标分支的改动也加到当前分支，本节需要介绍一下分支合并的三种方式，<code>Fast-forward</code> 模式、普通模式、和 强制<code>Fast-forward</code> 模式</p>
<p><code>Fast-forward</code> 模式是指<code>master</code>合并<code>dev</code>时候发现<code>master</code>节点一直和<code>dev</code>的根节点相同，没有发生改变，那么<code>master</code>快速移动头指针到<code>dev</code>的位置，所以 <strong>Fast-forward 并不会发生真正的合并</strong>，只是通过移动指针造成合并的假象，这也体现 Git 设计的巧妙之处。</p>
<p><code>Fast-Forward</code>的合并方式固然简单，但是也有缺点，那就是删除了<code>dev</code>分支之后，就没办法看到它的记录了，好像它没有存在过一样，只剩下了线性的<code>master</code>分支。</p>
<p>如果想要保留一份合并的记录，可以使用<code>non-Fast-forward</code>模式，也就是普通模式，指定<code>--no-ff</code>参数，这样就可以强制禁用<code>Fast-Forward</code>模式了，这样做的好处是<strong>在任何情况下都会创建新的 commit 进行合并（即使当前节点相对于目标分支的根节点并没有改动）</strong>，它的命令是<code>merge --no-ff -m &quot;some message&quot; &lt;目标分支&gt;</code>，可以体现相对真实的merge记录。</p>
<p>最后一种情况就是强制<code>Fast-forward</code> 模式，它只会按照 <code>Fast-forward</code> 模式进行合并，如果不符合条件，则会拒绝合并请求并且退出，这种模式只适合追求干净线性git记录的小型团队。</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>合并分支并不是每次都能一帆风顺的，偶尔也会产生冲突。不过也不用过于担心，因为只要不是两个分支同时编辑了同一个文件的相同部分，就不会有冲突。</p>
<p>像下面这种情况，当前分支和目标分支都有不同的改动，并且恰好改动的是同一个文件的相同部分</p>
<p><a href="/../pic/image-20240305191414716.png" title="image-20240305191414716" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/image-20240305191414716.png" alt="image-20240305191414716"></a></p>
<p>此时想要将<code>feature1</code>分支的改动加入到<code>master</code>分支中，就会产生冲突，<strong>Git会提示我们哪个文件产生了冲突，需要手动解决冲突然后再提交一次。</strong></p>
<p>在产生冲突的文件中，Git会在需要解决冲突的部分用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出来，修改之后使用命令<code>git add &lt;冲突文件名&gt;</code>，<code>git commit -m &quot;message&quot;</code>就行了。此时的状态如下图所示。使用<code>git log --gragh</code>命令可以查看分支合并图。</p>
<p><a href="/../pic/image-20240305193659567.png" title="image-20240305193659567" class="gallery-item" style="box-shadow: none;"> <img src="/../pic/image-20240305193659567.png" alt="image-20240305193659567"></a></p>
<p>确认没问题之后，可以删除掉<code>feature1</code>分支。</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag）,这样方便我们查看版本信息。</p>
<p>本质上来说，标签也是一个指针，他是指向某次提交的死指针，给某次提交打上标签之后，就一直跟某次提交绑定在一起。</p>
<ul>
<li><p>创建标签</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tagname&gt;	<span class="comment"># 给当前提交创建一个标签，比如 git tag v1.0</span></span><br><span class="line">git tag &lt;tagname&gt; &lt;commit <span class="built_in">id</span>&gt;		<span class="comment"># 给历史提交创建标签，需要查找到它的commit id</span></span><br><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">&quot;some message&quot;</span> &lt;commit <span class="built_in">id</span>&gt;		<span class="comment"># 不仅可以创建标签，还可以创建标签的补充信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看标签信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag		<span class="comment"># 查看已创建的标签名称，这个排序是按字母顺序的，跟时间无关</span></span><br><span class="line">git show &lt;tagname&gt;		<span class="comment"># 显示该标签对应提交的详细信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推送某个标签到远程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;	<span class="comment"># 推送一个标签到远程</span></span><br><span class="line">git push origin --tags		<span class="comment"># 一次性推送所有的标签到远程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除标签</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;		<span class="comment"># 本地删除一个标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已经将标签推送到远程，想要删除有点麻烦，需要先在本地删除掉这个标签，然后使用下面的命令</span></span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;		</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>有些时候，Git的工作目录中有一些文件必须存在，但又不能提交它们，比如下面这些：</p>
<ol>
<li>程序本地开发使用的图片文件，缩略图等</li>
<li>程序运行时产生的垃圾文件和缓存文件（临时文件）等。</li>
<li>编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>你自己的带有敏感信息的配置文件，比如存放口令的配置文件，连接数据库的配置文件等。</li>
</ol>
<p>要解决这个问题，需要在Git的工作目录中添加一个文件<code>.gitignore</code>，在这个文件中写入想要忽略的文件名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thumbs.db		<span class="comment"># 具体的文件名</span></span><br><span class="line">Desktop.ini		<span class="comment"># 具体的文件名</span></span><br><span class="line">*.jpg			<span class="comment"># `*`代表匹配所有字符，此处是忽略所有以`.jpg`结尾的文件</span></span><br><span class="line">.*				<span class="comment"># 忽略所有`.`开头的文件，即隐藏文件</span></span><br><span class="line">*.py[cod]		<span class="comment"># `[cod]`代表匹配中括号中的任意一个字符，此处是忽略任何以`.pyc`,`pyo`,`pyd`结尾的文件</span></span><br><span class="line">cache/			<span class="comment"># 忽略`cache`目录以及其子目录下的所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外需要注意一个问题，就是`.gitignore`文件必须添加到版本库中，可以用下面这种方式来添加例外规则</span></span><br><span class="line">!.gitignore		<span class="comment"># 这样表示在不破坏上面规则的情况下，把这个文件提交到版本库</span></span><br></pre></td></tr></table></figure>



</div><script src="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-05-15</span>
            
                <span>该篇文章被 邓胖胖</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Git/'>
                            Git
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>
                            学习笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
             

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>